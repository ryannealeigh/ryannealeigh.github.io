{"version":3,"file":"tippy.iife.min.js","sources":["../src/props.ts","../src/constants.ts","../src/bindGlobalEventListeners.ts","../src/browser.ts","../src/reference.ts","../src/utils.ts","../src/popper.ts","../src/createTippy.ts","../src/index.ts","../src/addons/delegate.ts","../src/plugins/sticky.ts","../build/base-iife.js","../src/plugins/animateFill.ts","../src/plugins/followCursor.ts","../src/plugins/inlinePositioning.ts","../src/addons/createSingleton.ts"],"sourcesContent":["import {Props, Plugin} from './types';\n\nexport const defaultProps: Props = {\n  allowHTML: true,\n  animation: 'fade',\n  appendTo: (): Element => document.body,\n  aria: 'describedby',\n  arrow: true,\n  boundary: 'scrollParent',\n  content: '',\n  delay: 0,\n  distance: 10,\n  duration: [300, 250],\n  flip: true,\n  flipBehavior: 'flip',\n  flipOnUpdate: false,\n  hideOnClick: true,\n  ignoreAttributes: false,\n  inertia: false,\n  interactive: false,\n  interactiveBorder: 2,\n  interactiveDebounce: 0,\n  lazy: true,\n  maxWidth: 350,\n  multiple: false,\n  offset: 0,\n  onAfterUpdate(): void {},\n  onBeforeUpdate(): void {},\n  onCreate(): void {},\n  onDestroy(): void {},\n  onHidden(): void {},\n  onHide(): void | false {},\n  onMount(): void {},\n  onShow(): void | false {},\n  onShown(): void {},\n  onTrigger(): void {},\n  onUntrigger(): void {},\n  placement: 'top',\n  popperOptions: {},\n  role: 'tooltip',\n  showOnCreate: false,\n  theme: '',\n  touch: true,\n  trigger: 'mouseenter focus',\n  triggerTarget: null,\n  updateDuration: 0,\n  zIndex: 9999,\n};\n\n/**\n * If the setProps() method encounters one of these, the popperInstance must be\n * recreated\n */\nexport const POPPER_INSTANCE_DEPENDENCIES: Array<keyof Props> = [\n  'arrow',\n  'boundary',\n  'distance',\n  'flip',\n  'flipBehavior',\n  'flipOnUpdate',\n  'offset',\n  'placement',\n  'popperOptions',\n];\n\nexport function getExtendedProps(props: Props, plugins: Plugin[]): Props {\n  return {\n    ...props,\n    ...plugins.reduce<{[key: string]: any}>((acc, plugin) => {\n      const {name, defaultValue} = plugin;\n\n      if (name) {\n        acc[name] = props[name] !== undefined ? props[name] : defaultValue;\n      }\n\n      return acc;\n    }, {}),\n  };\n}\n","export const PASSIVE = {passive: true};\n\nexport const ROUND_ARROW =\n  '<svg viewBox=\"0 0 18 7\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M0 7s2.021-.015 5.253-4.218C6.584 1.051 7.797.007 9 0c1.203-.007 2.416 1.035 3.761 2.782C16.012 7.005 18 7 18 7H0z\"/></svg>';\n\nexport const IOS_CLASS = `__NAMESPACE_PREFIX__-iOS`;\nexport const POPPER_CLASS = `__NAMESPACE_PREFIX__-popper`;\nexport const TOOLTIP_CLASS = `__NAMESPACE_PREFIX__-tooltip`;\nexport const CONTENT_CLASS = `__NAMESPACE_PREFIX__-content`;\nexport const BACKDROP_CLASS = `__NAMESPACE_PREFIX__-backdrop`;\nexport const ARROW_CLASS = `__NAMESPACE_PREFIX__-arrow`;\nexport const SVG_ARROW_CLASS = `__NAMESPACE_PREFIX__-svg-arrow`;\n\nexport const POPPER_SELECTOR = `.${POPPER_CLASS}`;\nexport const TOOLTIP_SELECTOR = `.${TOOLTIP_CLASS}`;\nexport const CONTENT_SELECTOR = `.${CONTENT_CLASS}`;\nexport const BACKDROP_SELECTOR = `.${BACKDROP_CLASS}`;\nexport const ARROW_SELECTOR = `.${ARROW_CLASS}`;\nexport const SVG_ARROW_SELECTOR = `.${SVG_ARROW_CLASS}`;\n","import {PASSIVE} from './constants';\n\nexport const currentInput = {isTouch: false};\nlet lastMouseMoveTime = 0;\n\n/**\n * When a `touchstart` event is fired, it's assumed the user is using touch\n * input. We'll bind a `mousemove` event listener to listen for mouse input in\n * the future. This way, the `isTouch` property is fully dynamic and will handle\n * hybrid devices that use a mix of touch + mouse input.\n */\nexport function onDocumentTouchStart(): void {\n  if (currentInput.isTouch) {\n    return;\n  }\n\n  currentInput.isTouch = true;\n\n  if (window.performance) {\n    document.addEventListener('mousemove', onDocumentMouseMove);\n  }\n}\n\n/**\n * When two `mousemove` event are fired consecutively within 20ms, it's assumed\n * the user is using mouse input again. `mousemove` can fire on touch devices as\n * well, but very rarely that quickly.\n */\nexport function onDocumentMouseMove(): void {\n  const now = performance.now();\n\n  if (now - lastMouseMoveTime < 20) {\n    currentInput.isTouch = false;\n\n    document.removeEventListener('mousemove', onDocumentMouseMove);\n  }\n\n  lastMouseMoveTime = now;\n}\n\n/**\n * When an element is in focus and has a tippy, leaving the tab/window and\n * returning causes it to show again. For mouse users this is unexpected, but\n * for keyboard use it makes sense.\n * TODO: find a better technique to solve this problem\n */\nexport function onWindowBlur(): void {\n  const {activeElement}: {activeElement: any} = document;\n  const instance = activeElement._tippy;\n\n  if (\n    activeElement &&\n    activeElement.blur &&\n    instance &&\n    !instance.state.isVisible\n  ) {\n    activeElement.blur();\n  }\n}\n\n/**\n * Adds the needed global event listeners\n */\nexport default function bindGlobalEventListeners(): void {\n  document.addEventListener('touchstart', onDocumentTouchStart, {\n    ...PASSIVE,\n    capture: true,\n  });\n  window.addEventListener('blur', onWindowBlur);\n}\n","import {currentInput} from './bindGlobalEventListeners';\nimport {IOS_CLASS} from './constants';\n\nexport const isBrowser =\n  typeof window !== 'undefined' && typeof document !== 'undefined';\n\nconst ua = isBrowser ? navigator.userAgent : '';\n\nexport const isIE = /MSIE |Trident\\//.test(ua);\nexport const isUCBrowser = /UCBrowser\\//.test(ua);\nexport const isIOS = isBrowser && /iPhone|iPad|iPod/.test(navigator.platform);\n\nexport function updateIOSClass(isAdd: boolean): void {\n  const shouldAdd = isAdd && isIOS && currentInput.isTouch;\n  document.body.classList[shouldAdd ? 'add' : 'remove'](IOS_CLASS);\n}\n","import {ReferenceElement, Props, Plugin} from './types';\nimport {defaultProps, getExtendedProps} from './props';\n\nconst keys = Object.keys(defaultProps);\n\n/**\n * Returns an object of optional props from data-tippy-* attributes\n */\nexport function getDataAttributeProps(\n  reference: ReferenceElement,\n  plugins?: Plugin[],\n): Props {\n  const props = (plugins\n    ? Object.keys(getExtendedProps(defaultProps, plugins))\n    : keys\n  ).reduce((acc: any, key): Partial<Props> => {\n    const valueAsString = (\n      reference.getAttribute(`data-tippy-${key}`) || ''\n    ).trim();\n\n    if (!valueAsString) {\n      return acc;\n    }\n\n    if (key === 'content') {\n      acc[key] = valueAsString;\n    } else {\n      try {\n        acc[key] = JSON.parse(valueAsString);\n      } catch (e) {\n        acc[key] = valueAsString;\n      }\n    }\n\n    return acc;\n  }, {});\n\n  return props;\n}\n","import {Props, ReferenceElement, Targets, Plugin} from './types';\nimport {getDataAttributeProps} from './reference';\n\n/**\n * Determines if the value is a reference element\n */\nexport function isReferenceElement(value: any): value is ReferenceElement {\n  return !!(value && value._tippy && value._tippy.reference === value);\n}\n\n/**\n * Safe .hasOwnProperty check, for prototype-less objects\n */\nexport function hasOwnProperty(obj: object, key: string): boolean {\n  return {}.hasOwnProperty.call(obj, key);\n}\n\n/**\n * Returns an array of elements based on the value\n */\nexport function getArrayOfElements(value: Targets): Element[] {\n  if (isElement(value)) {\n    return [value];\n  }\n\n  if (isNodeList(value)) {\n    return arrayFrom(value);\n  }\n\n  if (Array.isArray(value)) {\n    return value;\n  }\n\n  return arrayFrom(document.querySelectorAll(value));\n}\n\n/**\n * Returns a value at a given index depending on if it's an array or number\n */\nexport function getValueAtIndexOrReturn<T>(\n  value: T | T[],\n  index: number,\n  defaultValue: T | T[],\n): T {\n  if (Array.isArray(value)) {\n    const v = value[index];\n    return v == null\n      ? Array.isArray(defaultValue)\n        ? defaultValue[index]\n        : defaultValue\n      : v;\n  }\n\n  return value;\n}\n\n/**\n * Prevents errors from being thrown while accessing nested modifier objects\n * in `popperOptions`\n */\nexport function getModifier(obj: any, key: string): any {\n  return obj && obj.modifiers && obj.modifiers[key];\n}\n\n/**\n * Determines if the value is of type\n */\nexport function isType(value: any, type: string): boolean {\n  const str = {}.toString.call(value);\n  return str.indexOf('[object') === 0 && str.indexOf(`${type}]`) > -1;\n}\n\n/**\n * Determines if the value is of type Element\n */\nexport function isElement(value: any): value is Element {\n  return isType(value, 'Element');\n}\n\n/**\n * Determines if the value is of type NodeList\n */\nexport function isNodeList(value: any): value is NodeList {\n  return isType(value, 'NodeList');\n}\n\n/**\n * Determines if the value is of type MouseEvent\n */\nexport function isMouseEvent(value: any): value is MouseEvent {\n  return isType(value, 'MouseEvent');\n}\n\n/**\n * Firefox extensions don't allow setting .innerHTML directly, this will trick\n * it\n */\nexport function innerHTML(): 'innerHTML' {\n  return 'innerHTML';\n}\n\n/**\n * Evaluates a function if one, or returns the value\n */\nexport function invokeWithArgsOrReturn(value: any, args: any[]): any {\n  return typeof value === 'function' ? value(...args) : value;\n}\n\n/**\n * Sets a popperInstance `flip` modifier's enabled state\n */\nexport function setFlipModifierEnabled(modifiers: any[], value: any): void {\n  modifiers.filter((m): boolean => m.name === 'flip')[0].enabled = value;\n}\n\n/**\n * Returns a new `div` element\n */\nexport function div(): HTMLDivElement {\n  return document.createElement('div');\n}\n\n/**\n * Applies a transition duration to a list of elements\n */\nexport function setTransitionDuration(\n  els: (HTMLDivElement | null)[],\n  value: number,\n): void {\n  els.forEach((el): void => {\n    if (el) {\n      el.style.transitionDuration = `${value}ms`;\n    }\n  });\n}\n\n/**\n * Sets the visibility state to elements so they can begin to transition\n */\nexport function setVisibilityState(\n  els: (HTMLDivElement | null)[],\n  state: 'visible' | 'hidden',\n): void {\n  els.forEach((el): void => {\n    if (el) {\n      el.setAttribute('data-state', state);\n    }\n  });\n}\n\n/**\n * Evaluates the props object by merging data attributes and disabling\n * conflicting props where necessary\n */\nexport function evaluateProps(\n  reference: ReferenceElement,\n  props: Props,\n  plugins: Plugin[],\n): Props {\n  const out = {\n    ...props,\n    content: invokeWithArgsOrReturn(props.content, [reference]),\n    ...(props.ignoreAttributes\n      ? {}\n      : getDataAttributeProps(reference, plugins)),\n  };\n\n  if (out.interactive) {\n    out.aria = null;\n  }\n\n  return out;\n}\n\n/**\n * Debounce utility. To avoid bloating bundle size, we're only passing 1\n * argument here, a more generic function would pass all arguments. Only\n * `onMouseMove` uses this which takes the event object for now.\n */\nexport function debounce<T>(\n  fn: (arg: T) => void,\n  ms: number,\n): (arg: T) => void {\n  // Avoid wrapping in `setTimeout` if ms is 0 anyway\n  if (ms === 0) {\n    return fn;\n  }\n\n  let timeout: any;\n\n  return (arg): void => {\n    clearTimeout(timeout);\n    timeout = setTimeout((): void => {\n      fn(arg);\n    }, ms);\n  };\n}\n\n/**\n * Preserves the original function invocation when another function replaces it\n */\nexport function preserveInvocation<T>(\n  originalFn: undefined | ((...args: any) => void),\n  currentFn: undefined | ((...args: any) => void),\n  args: T[],\n): void {\n  if (originalFn && originalFn !== currentFn) {\n    originalFn(...args);\n  }\n}\n\n/**\n * Deletes properties from an object (pure)\n */\nexport function removeProperties<T>(obj: T, keys: Array<keyof T>): Partial<T> {\n  const clone = {...obj};\n  keys.forEach((key): void => {\n    delete clone[key];\n  });\n  return clone;\n}\n\n/**\n * Ponyfill for Array.from - converts iterable values to an array\n */\nexport function arrayFrom(value: ArrayLike<any>): any[] {\n  return [].slice.call(value);\n}\n\n/**\n * Works like Element.prototype.closest, but uses a callback instead\n */\nexport function closestCallback(\n  element: Element | null,\n  callback: Function,\n): Element | null {\n  while (element) {\n    if (callback(element)) {\n      return element;\n    }\n\n    element = element.parentElement;\n  }\n\n  return null;\n}\n\n/**\n * Determines if an array or string includes a string\n */\nexport function includes(a: string[] | string, b: string): boolean {\n  return a.indexOf(b) > -1;\n}\n\n/**\n * Creates an array from string of values separated by whitespace\n */\nexport function splitBySpaces(value: string): string[] {\n  return value.split(/\\s+/).filter(Boolean);\n}\n\n/**\n * Returns the `nextValue` if `nextValue` is not `undefined`, otherwise returns\n * `currentValue`\n */\nexport function useIfDefined(nextValue: any, currentValue: any): any {\n  return nextValue !== undefined ? nextValue : currentValue;\n}\n\n/**\n * Converts a value that's an array or single value to an array\n */\nexport function normalizeToArray<T>(value: T | T[]): T[] {\n  // @ts-ignore\n  return [].concat(value);\n}\n\n/**\n * Returns the ownerDocument of the first available element, otherwise global\n * document\n */\nexport function getOwnerDocument(\n  elementOrElements: Element | Element[],\n): Document {\n  const [element] = normalizeToArray(elementOrElements);\n  return element ? element.ownerDocument || document : document;\n}\n\n/**\n * Adds item to array if array does not contain it\n */\nexport function pushIfUnique<T>(arr: T[], value: T): void {\n  if (arr.indexOf(value) === -1) {\n    arr.push(value);\n  }\n}\n\n/**\n * Adds `px` if value is a number, or returns it directly\n */\nexport function appendPxIfNumber(value: string | number): string {\n  return typeof value === 'number' ? `${value}px` : value;\n}\n","import {\n  PopperElement,\n  Props,\n  PopperChildren,\n  BasePlacement,\n  Placement,\n} from './types';\nimport {\n  innerHTML,\n  div,\n  isElement,\n  splitBySpaces,\n  appendPxIfNumber,\n} from './utils';\nimport {isUCBrowser} from './browser';\nimport {\n  POPPER_CLASS,\n  TOOLTIP_CLASS,\n  CONTENT_CLASS,\n  ARROW_CLASS,\n  SVG_ARROW_CLASS,\n  TOOLTIP_SELECTOR,\n  CONTENT_SELECTOR,\n  ARROW_SELECTOR,\n  SVG_ARROW_SELECTOR,\n} from './constants';\n\n/**\n * Sets the innerHTML of an element\n */\nexport function setInnerHTML(element: Element, html: string | Element): void {\n  element[innerHTML()] = isElement(html) ? html[innerHTML()] : html;\n}\n\n/**\n * Sets the content of a tooltip\n */\nexport function setContent(\n  contentEl: PopperChildren['content'],\n  props: Props,\n): void {\n  if (isElement(props.content)) {\n    setInnerHTML(contentEl, '');\n    contentEl.appendChild(props.content);\n  } else if (typeof props.content !== 'function') {\n    const key: 'innerHTML' | 'textContent' = props.allowHTML\n      ? 'innerHTML'\n      : 'textContent';\n    contentEl[key] = props.content;\n  }\n}\n\n/**\n * Returns the child elements of a popper element\n */\nexport function getChildren(popper: PopperElement): PopperChildren {\n  return {\n    tooltip: popper.querySelector(TOOLTIP_SELECTOR) as HTMLDivElement,\n    content: popper.querySelector(CONTENT_SELECTOR) as HTMLDivElement,\n    arrow:\n      popper.querySelector(ARROW_SELECTOR) ||\n      popper.querySelector(SVG_ARROW_SELECTOR),\n  };\n}\n\n/**\n * Adds `data-inertia` attribute\n */\nexport function addInertia(tooltip: PopperChildren['tooltip']): void {\n  tooltip.setAttribute('data-inertia', '');\n}\n\n/**\n * Removes `data-inertia` attribute\n */\nexport function removeInertia(tooltip: PopperChildren['tooltip']): void {\n  tooltip.removeAttribute('data-inertia');\n}\n\n/**\n * Creates an arrow element and returns it\n */\nexport function createArrowElement(arrow: Props['arrow']): HTMLDivElement {\n  const arrowElement = div();\n\n  if (arrow === true) {\n    arrowElement.className = ARROW_CLASS;\n  } else {\n    arrowElement.className = SVG_ARROW_CLASS;\n\n    if (isElement(arrow)) {\n      arrowElement.appendChild(arrow);\n    } else {\n      setInnerHTML(arrowElement, arrow as string);\n    }\n  }\n\n  return arrowElement;\n}\n\n/**\n * Adds interactive-related attributes\n */\nexport function addInteractive(tooltip: PopperChildren['tooltip']): void {\n  tooltip.setAttribute('data-interactive', '');\n}\n\n/**\n * Removes interactive-related attributes\n */\nexport function removeInteractive(tooltip: PopperChildren['tooltip']): void {\n  tooltip.removeAttribute('data-interactive');\n}\n\n/**\n * Add/remove transitionend listener from tooltip\n */\nexport function updateTransitionEndListener(\n  tooltip: PopperChildren['tooltip'],\n  action: 'add' | 'remove',\n  listener: (event: TransitionEvent) => void,\n): void {\n  const eventName =\n    isUCBrowser && document.body.style.webkitTransition !== undefined\n      ? 'webkitTransitionEnd'\n      : 'transitionend';\n  tooltip[\n    (action + 'EventListener') as 'addEventListener' | 'removeEventListener'\n  ](eventName, listener as EventListener);\n}\n\n/**\n * Returns the popper's placement, ignoring shifting (top-start, etc)\n */\nexport function getBasePlacement(placement: Placement): BasePlacement {\n  return placement.split('-')[0] as BasePlacement;\n}\n\n/**\n * Triggers reflow\n */\nexport function reflow(popper: PopperElement): void {\n  void popper.offsetHeight;\n}\n\n/**\n * Adds/removes theme from tooltip's classList\n */\nexport function updateTheme(\n  tooltip: PopperChildren['tooltip'],\n  action: 'add' | 'remove',\n  theme: Props['theme'],\n): void {\n  splitBySpaces(theme).forEach((name): void => {\n    tooltip.classList[action](`${name}-theme`);\n  });\n}\n\n/**\n * Constructs the popper element and returns it\n */\nexport function createPopperElement(id: number, props: Props): PopperElement {\n  const popper = div();\n  popper.className = POPPER_CLASS;\n  popper.style.position = 'absolute';\n  popper.style.top = '0';\n  popper.style.left = '0';\n\n  const tooltip = div();\n  tooltip.className = TOOLTIP_CLASS;\n  tooltip.id = `__NAMESPACE_PREFIX__-${id}`;\n  tooltip.setAttribute('data-state', 'hidden');\n  tooltip.setAttribute('tabindex', '-1');\n\n  updateTheme(tooltip, 'add', props.theme);\n\n  const content = div();\n  content.className = CONTENT_CLASS;\n  content.setAttribute('data-state', 'hidden');\n\n  if (props.interactive) {\n    addInteractive(tooltip);\n  }\n\n  if (props.arrow) {\n    tooltip.setAttribute('data-arrow', '');\n    tooltip.appendChild(createArrowElement(props.arrow));\n  }\n\n  if (props.inertia) {\n    addInertia(tooltip);\n  }\n\n  setContent(content, props);\n\n  tooltip.appendChild(content);\n  popper.appendChild(tooltip);\n\n  updatePopperElement(popper, props, props);\n\n  return popper;\n}\n\n/**\n * Updates the popper element based on the new props\n */\nexport function updatePopperElement(\n  popper: PopperElement,\n  prevProps: Props,\n  nextProps: Props,\n): void {\n  const {tooltip, content, arrow} = getChildren(popper);\n\n  popper.style.zIndex = '' + nextProps.zIndex;\n\n  tooltip.setAttribute('data-animation', nextProps.animation);\n  tooltip.style.maxWidth = appendPxIfNumber(nextProps.maxWidth);\n\n  if (nextProps.role) {\n    tooltip.setAttribute('role', nextProps.role);\n  } else {\n    tooltip.removeAttribute('role');\n  }\n\n  if (prevProps.content !== nextProps.content) {\n    setContent(content, nextProps);\n  }\n\n  // arrow\n  if (!prevProps.arrow && nextProps.arrow) {\n    // false to true\n    tooltip.appendChild(createArrowElement(nextProps.arrow));\n    tooltip.setAttribute('data-arrow', '');\n  } else if (prevProps.arrow && !nextProps.arrow) {\n    // true to false\n    tooltip.removeChild(arrow!);\n    tooltip.removeAttribute('data-arrow');\n  } else if (prevProps.arrow !== nextProps.arrow) {\n    // true to 'round' or vice-versa\n    tooltip.removeChild(arrow!);\n    tooltip.appendChild(createArrowElement(nextProps.arrow));\n  }\n\n  // interactive\n  if (!prevProps.interactive && nextProps.interactive) {\n    addInteractive(tooltip);\n  } else if (prevProps.interactive && !nextProps.interactive) {\n    removeInteractive(tooltip);\n  }\n\n  // inertia\n  if (!prevProps.inertia && nextProps.inertia) {\n    addInertia(tooltip);\n  } else if (prevProps.inertia && !nextProps.inertia) {\n    removeInertia(tooltip);\n  }\n\n  // theme\n  if (prevProps.theme !== nextProps.theme) {\n    updateTheme(tooltip, 'remove', prevProps.theme);\n    updateTheme(tooltip, 'add', nextProps.theme);\n  }\n}\n\n/**\n * Determines if the mouse cursor is outside of the popper's interactive border\n * region\n */\nexport function isCursorOutsideInteractiveBorder(\n  popperTreeData: {\n    popperRect: ClientRect;\n    interactiveBorder: Props['interactiveBorder'];\n  }[],\n  event: MouseEvent,\n): boolean {\n  const {clientX, clientY} = event;\n\n  return popperTreeData.every(({popperRect, interactiveBorder}) => {\n    const exceedsTop = popperRect.top > clientY + interactiveBorder;\n    const exceedsBottom = popperRect.bottom < clientY - interactiveBorder;\n    const exceedsLeft = popperRect.left > clientX + interactiveBorder;\n    const exceedsRight = popperRect.right < clientX - interactiveBorder;\n\n    return exceedsTop || exceedsBottom || exceedsLeft || exceedsRight;\n  });\n}\n","import Popper from 'popper.js';\nimport {\n  ReferenceElement,\n  PopperInstance,\n  Props,\n  Plugin,\n  Instance,\n  Content,\n  LifecycleHooks,\n  PopperElement,\n} from './types';\nimport {isIE, updateIOSClass} from './browser';\nimport {PASSIVE, POPPER_SELECTOR} from './constants';\nimport {currentInput} from './bindGlobalEventListeners';\nimport {\n  defaultProps,\n  POPPER_INSTANCE_DEPENDENCIES,\n  getExtendedProps,\n} from './props';\nimport {\n  createPopperElement,\n  updatePopperElement,\n  getChildren,\n  getBasePlacement,\n  updateTransitionEndListener,\n  isCursorOutsideInteractiveBorder,\n  reflow,\n} from './popper';\nimport {\n  hasOwnProperty,\n  getValueAtIndexOrReturn,\n  getModifier,\n  includes,\n  invokeWithArgsOrReturn,\n  setFlipModifierEnabled,\n  evaluateProps,\n  setTransitionDuration,\n  setVisibilityState,\n  debounce,\n  preserveInvocation,\n  closestCallback,\n  splitBySpaces,\n  normalizeToArray,\n  useIfDefined,\n  isMouseEvent,\n  getOwnerDocument,\n  pushIfUnique,\n  arrayFrom,\n  appendPxIfNumber,\n} from './utils';\nimport {warnWhen, validateProps, createMemoryLeakWarning} from './validation';\n\ninterface Listener {\n  node: Element;\n  eventType: string;\n  handler: EventListenerOrEventListenerObject;\n  options: boolean | object;\n}\n\nexport let mountedInstances: Instance[] = [];\n\nlet idCounter = 1;\n// Workaround for IE11's lack of new MouseEvent constructor\nlet mouseMoveListeners: ((event: MouseEvent) => void)[] = [];\n\n/**\n * Creates and returns a Tippy object. We're using a closure pattern instead of\n * a class so that the exposed object API is clean without private members\n * prefixed with `_`.\n */\nexport default function createTippy(\n  reference: ReferenceElement,\n  collectionProps: Props,\n  plugins: Plugin[] = [],\n): Instance | null {\n  const props = getExtendedProps(\n    evaluateProps(reference, collectionProps, plugins),\n    plugins,\n  );\n\n  // If the reference shouldn't have multiple tippys, return null early\n  if (!props.multiple && reference._tippy) {\n    return null;\n  }\n\n  /* ======================= 🔒 Private members 🔒 ======================= */\n  let showTimeout: any;\n  let hideTimeout: any;\n  let scheduleHideAnimationFrame: number;\n  let isBeingDestroyed = false;\n  let didHideDueToDocumentMouseDown = false;\n  let popperUpdates = 0;\n  let lastTriggerEvent: Event;\n  let currentMountCallback: () => void;\n  let currentTransitionEndListener: (event: TransitionEvent) => void;\n  let listeners: Listener[] = [];\n  let debouncedOnMouseMove = debounce(onMouseMove, props.interactiveDebounce);\n  let currentTarget: Element;\n\n  // Support iframe contexts\n  // Static check that assumes any of the `triggerTarget` or `reference`\n  // nodes will never change documents, even when they are updated\n  const doc = getOwnerDocument(props.triggerTarget || reference);\n\n  /* ======================= 🔑 Public members 🔑 ======================= */\n  const id = idCounter++;\n  const popper = createPopperElement(id, props);\n  const popperChildren = getChildren(popper);\n  const popperInstance: PopperInstance | null = null;\n\n  // These two elements are static\n  const {tooltip, content} = popperChildren;\n  const transitionableElements = [tooltip, content];\n\n  const state = {\n    // The current real placement (`data-placement` attribute)\n    currentPlacement: null,\n    // Is the instance currently enabled?\n    isEnabled: true,\n    // Is the tippy currently showing and not transitioning out?\n    isVisible: false,\n    // Has the instance been destroyed?\n    isDestroyed: false,\n    // Is the tippy currently mounted to the DOM?\n    isMounted: false,\n    // Has the tippy finished transitioning in?\n    isShown: false,\n  };\n\n  const instance: Instance = {\n    // properties\n    id,\n    reference,\n    popper,\n    popperChildren,\n    popperInstance,\n    props,\n    state,\n    plugins,\n    // methods\n    clearDelayTimeouts,\n    setProps,\n    setContent,\n    show,\n    hide,\n    enable,\n    disable,\n    destroy,\n  };\n\n  /* ==================== Initial instance mutations =================== */\n  reference._tippy = instance;\n  popper._tippy = instance;\n\n  const pluginsHooks = plugins.map(plugin => plugin.fn(instance));\n\n  addListenersToTriggerTarget();\n  handleAriaExpandedAttribute();\n\n  if (!props.lazy) {\n    createPopperInstance();\n  }\n\n  invokeHook('onCreate', [instance]);\n\n  if (props.showOnCreate) {\n    scheduleShow();\n  }\n\n  // Prevent a tippy with a delay from hiding if the cursor left then returned\n  // before it started hiding\n  popper.addEventListener('mouseenter', (): void => {\n    if (instance.props.interactive && instance.state.isVisible) {\n      instance.clearDelayTimeouts();\n    }\n  });\n\n  popper.addEventListener('mouseleave', (): void => {\n    if (\n      instance.props.interactive &&\n      includes(instance.props.trigger, 'mouseenter')\n    ) {\n      doc.addEventListener('mousemove', debouncedOnMouseMove);\n    }\n  });\n\n  return instance;\n\n  /* ======================= 🔒 Private methods 🔒 ======================= */\n  function getNormalizedTouchSettings(): [string | boolean, number] {\n    const {touch} = instance.props;\n    return Array.isArray(touch) ? touch : [touch, 0];\n  }\n\n  function getIsCustomTouchBehavior(): boolean {\n    return getNormalizedTouchSettings()[0] === 'hold';\n  }\n\n  function getCurrentTarget(): Element {\n    return currentTarget || reference;\n  }\n\n  function getDelay(isShow: boolean): number {\n    // For touch or keyboard input, force `0` delay for UX reasons\n    // Also if the instance is mounted but not visible (transitioning out),\n    // ignore delay\n    if (\n      (instance.state.isMounted && !instance.state.isVisible) ||\n      currentInput.isTouch ||\n      (lastTriggerEvent ? lastTriggerEvent.type === 'focus' : true)\n    ) {\n      return 0;\n    }\n\n    return getValueAtIndexOrReturn(\n      instance.props.delay,\n      isShow ? 0 : 1,\n      defaultProps.delay,\n    );\n  }\n\n  function invokeHook(\n    hook: keyof LifecycleHooks,\n    args: [Instance, (Event | Partial<Props>)?],\n    shouldInvokePropsHook = true,\n  ): void {\n    pluginsHooks.forEach(pluginHooks => {\n      if (hasOwnProperty(pluginHooks, hook)) {\n        // @ts-ignore\n        pluginHooks[hook](...args);\n      }\n    });\n\n    if (shouldInvokePropsHook) {\n      // @ts-ignore\n      instance.props[hook](...args);\n    }\n  }\n\n  function handleAriaDescribedByAttribute(): void {\n    const {aria} = instance.props;\n\n    if (!aria) {\n      return;\n    }\n\n    const attr = `aria-${aria}`;\n    const id = tooltip.id;\n    const nodes = normalizeToArray(instance.props.triggerTarget || reference);\n\n    nodes.forEach((node): void => {\n      const currentValue = node.getAttribute(attr);\n\n      if (instance.state.isVisible) {\n        node.setAttribute(attr, currentValue ? `${currentValue} ${id}` : id);\n      } else {\n        const nextValue = currentValue && currentValue.replace(id, '').trim();\n\n        if (nextValue) {\n          node.setAttribute(attr, nextValue);\n        } else {\n          node.removeAttribute(attr);\n        }\n      }\n    });\n  }\n\n  function handleAriaExpandedAttribute(): void {\n    const nodes = normalizeToArray(instance.props.triggerTarget || reference);\n\n    nodes.forEach((node): void => {\n      if (instance.props.interactive) {\n        node.setAttribute(\n          'aria-expanded',\n          instance.state.isVisible && node === getCurrentTarget()\n            ? 'true'\n            : 'false',\n        );\n      } else {\n        node.removeAttribute('aria-expanded');\n      }\n    });\n  }\n\n  function cleanupInteractiveMouseListeners(): void {\n    doc.body.removeEventListener('mouseleave', scheduleHide);\n    doc.removeEventListener('mousemove', debouncedOnMouseMove);\n    mouseMoveListeners = mouseMoveListeners.filter(\n      (listener): boolean => listener !== debouncedOnMouseMove,\n    );\n  }\n\n  function onDocumentMouseDown(event: MouseEvent): void {\n    // Clicked on interactive popper\n    if (\n      instance.props.interactive &&\n      popper.contains(event.target as Element)\n    ) {\n      return;\n    }\n\n    // Clicked on the event listeners target\n    if (getCurrentTarget().contains(event.target as Element)) {\n      if (currentInput.isTouch) {\n        return;\n      }\n\n      if (\n        instance.state.isVisible &&\n        includes(instance.props.trigger, 'click')\n      ) {\n        return;\n      }\n    }\n\n    if (instance.props.hideOnClick === true) {\n      instance.clearDelayTimeouts();\n      instance.hide();\n\n      // `mousedown` event is fired right before `focus` if pressing the\n      // currentTarget. This lets a tippy with `focus` trigger know that it\n      // should not show\n      didHideDueToDocumentMouseDown = true;\n      setTimeout((): void => {\n        didHideDueToDocumentMouseDown = false;\n      });\n\n      // The listener gets added in `scheduleShow()`, but this may be hiding it\n      // before it shows, and hide()'s early bail-out behavior can prevent it\n      // from being cleaned up\n      if (!instance.state.isMounted) {\n        removeDocumentMouseDownListener();\n      }\n    }\n  }\n\n  function addDocumentMouseDownListener(): void {\n    doc.addEventListener('mousedown', onDocumentMouseDown, true);\n  }\n\n  function removeDocumentMouseDownListener(): void {\n    doc.removeEventListener('mousedown', onDocumentMouseDown, true);\n  }\n\n  function onTransitionedOut(duration: number, callback: () => void): void {\n    onTransitionEnd(duration, (): void => {\n      if (\n        !instance.state.isVisible &&\n        popper.parentNode &&\n        popper.parentNode.contains(popper)\n      ) {\n        callback();\n      }\n    });\n  }\n\n  function onTransitionedIn(duration: number, callback: () => void): void {\n    onTransitionEnd(duration, callback);\n  }\n\n  function onTransitionEnd(duration: number, callback: () => void): void {\n    /**\n     * Listener added as the `transitionend` handler\n     */\n    function listener(event: TransitionEvent): void {\n      if (event.target === tooltip) {\n        updateTransitionEndListener(tooltip, 'remove', listener);\n        callback();\n      }\n    }\n\n    // Make callback synchronous if duration is 0\n    // `transitionend` won't fire otherwise\n    if (duration === 0) {\n      return callback();\n    }\n\n    updateTransitionEndListener(\n      tooltip,\n      'remove',\n      currentTransitionEndListener,\n    );\n    updateTransitionEndListener(tooltip, 'add', listener);\n\n    currentTransitionEndListener = listener;\n  }\n\n  function on(\n    eventType: string,\n    handler: EventListener,\n    options: boolean | object = false,\n  ): void {\n    const nodes = normalizeToArray(instance.props.triggerTarget || reference);\n    nodes.forEach(node => {\n      node.addEventListener(eventType, handler, options);\n      listeners.push({node, eventType, handler, options});\n    });\n  }\n\n  function addListenersToTriggerTarget(): void {\n    if (getIsCustomTouchBehavior()) {\n      on('touchstart', onTrigger, PASSIVE);\n      on('touchend', onMouseLeave as EventListener, PASSIVE);\n    }\n\n    splitBySpaces(instance.props.trigger).forEach((eventType): void => {\n      if (eventType === 'manual') {\n        return;\n      }\n\n      on(eventType, onTrigger);\n\n      switch (eventType) {\n        case 'mouseenter':\n          on('mouseleave', onMouseLeave as EventListener);\n          break;\n        case 'focus':\n          on(isIE ? 'focusout' : 'blur', onBlur as EventListener);\n          break;\n      }\n    });\n  }\n\n  function removeListenersFromTriggerTarget(): void {\n    listeners.forEach(({node, eventType, handler, options}: Listener): void => {\n      node.removeEventListener(eventType, handler, options);\n    });\n    listeners = [];\n  }\n\n  function onTrigger(event: Event): void {\n    if (\n      !instance.state.isEnabled ||\n      isEventListenerStopped(event) ||\n      didHideDueToDocumentMouseDown\n    ) {\n      return;\n    }\n\n    lastTriggerEvent = event;\n    currentTarget = event.currentTarget as Element;\n\n    handleAriaExpandedAttribute();\n\n    if (!instance.state.isVisible && isMouseEvent(event)) {\n      // If scrolling, `mouseenter` events can be fired if the cursor lands\n      // over a new target, but `mousemove` events don't get fired. This\n      // causes interactive tooltips to get stuck open until the cursor is\n      // moved\n      mouseMoveListeners.forEach((listener): void => listener(event));\n    }\n\n    // Toggle show/hide when clicking click-triggered tooltips\n    if (\n      event.type === 'click' &&\n      instance.props.hideOnClick !== false &&\n      instance.state.isVisible\n    ) {\n      scheduleHide(event);\n    } else {\n      const [value, duration] = getNormalizedTouchSettings();\n\n      if (currentInput.isTouch && value === 'hold' && duration) {\n        // We can hijack the show timeout here, it will be cleared by\n        // `scheduleHide()` when necessary\n        showTimeout = setTimeout((): void => {\n          scheduleShow(event);\n        }, duration);\n      } else {\n        scheduleShow(event);\n      }\n    }\n  }\n\n  function onMouseMove(event: MouseEvent): void {\n    const isCursorOverReferenceOrPopper = closestCallback(\n      event.target as Element,\n      (el: Element): boolean => el === reference || el === popper,\n    );\n\n    if (isCursorOverReferenceOrPopper) {\n      return;\n    }\n\n    const popperTreeData = arrayFrom(popper.querySelectorAll(POPPER_SELECTOR))\n      .concat(popper)\n      .map((popper: PopperElement) => ({\n        popperRect: popper.getBoundingClientRect(),\n        interactiveBorder: popper._tippy!.props.interactiveBorder,\n      }));\n\n    if (isCursorOutsideInteractiveBorder(popperTreeData, event)) {\n      cleanupInteractiveMouseListeners();\n      scheduleHide(event);\n    }\n  }\n\n  function onMouseLeave(event: MouseEvent): void {\n    if (isEventListenerStopped(event)) {\n      return;\n    }\n\n    if (instance.props.interactive) {\n      doc.body.addEventListener('mouseleave', scheduleHide);\n      doc.addEventListener('mousemove', debouncedOnMouseMove);\n      pushIfUnique(mouseMoveListeners, debouncedOnMouseMove);\n\n      return;\n    }\n\n    scheduleHide(event);\n  }\n\n  function onBlur(event: FocusEvent): void {\n    if (event.target !== getCurrentTarget()) {\n      return;\n    }\n\n    // If focus was moved to within the popper\n    if (\n      instance.props.interactive &&\n      event.relatedTarget &&\n      popper.contains(event.relatedTarget as Element)\n    ) {\n      return;\n    }\n\n    scheduleHide(event);\n  }\n\n  function isEventListenerStopped(event: Event): boolean {\n    const supportsTouch = 'ontouchstart' in window;\n    const isTouchEvent = includes(event.type, 'touch');\n    const isCustomTouch = getIsCustomTouchBehavior();\n\n    return (\n      (supportsTouch &&\n        currentInput.isTouch &&\n        isCustomTouch &&\n        !isTouchEvent) ||\n      (currentInput.isTouch && !isCustomTouch && isTouchEvent)\n    );\n  }\n\n  function createPopperInstance(): void {\n    const {popperOptions} = instance.props;\n    const {arrow} = instance.popperChildren;\n\n    function applyMutations(data: Popper.Data): void {\n      instance.state.currentPlacement = data.placement;\n\n      if (instance.props.flip && !instance.props.flipOnUpdate) {\n        if (data.flipped) {\n          instance.popperInstance!.options.placement = data.placement;\n        }\n\n        setFlipModifierEnabled(instance.popperInstance!.modifiers, false);\n      }\n\n      tooltip.setAttribute('data-placement', data.placement);\n      if (data.attributes['x-out-of-boundaries'] !== false) {\n        tooltip.setAttribute('data-out-of-boundaries', '');\n      } else {\n        tooltip.removeAttribute('data-out-of-boundaries');\n      }\n\n      const basePlacement = getBasePlacement(data.placement);\n      const distance = appendPxIfNumber(instance.props.distance);\n\n      const padding = {\n        bottom: `${distance} 0 0 0`,\n        left: `0 ${distance} 0 0`,\n        top: `0 0 ${distance} 0`,\n        right: `0 0 0 ${distance}`,\n      };\n\n      popper.style.padding = padding[basePlacement];\n    }\n\n    const config = {\n      eventsEnabled: false,\n      placement: instance.props.placement,\n      ...popperOptions,\n      modifiers: {\n        ...(popperOptions && popperOptions.modifiers),\n        preventOverflow: {\n          boundariesElement: instance.props.boundary,\n          ...getModifier(popperOptions, 'preventOverflow'),\n        },\n        arrow: {\n          element: arrow,\n          enabled: !!arrow,\n          ...getModifier(popperOptions, 'arrow'),\n        },\n        flip: {\n          enabled: instance.props.flip,\n          behavior: instance.props.flipBehavior,\n          ...getModifier(popperOptions, 'flip'),\n        },\n        offset: {\n          offset: instance.props.offset,\n          ...getModifier(popperOptions, 'offset'),\n        },\n      },\n      onCreate(data: Popper.Data): void {\n        applyMutations(data);\n\n        preserveInvocation(\n          popperOptions && popperOptions.onCreate,\n          config.onCreate,\n          [data],\n        );\n\n        runMountCallback();\n      },\n      onUpdate(data: Popper.Data): void {\n        applyMutations(data);\n\n        preserveInvocation(\n          popperOptions && popperOptions.onUpdate,\n          config.onUpdate,\n          [data],\n        );\n\n        runMountCallback();\n      },\n    };\n\n    instance.popperInstance = new Popper(\n      reference,\n      popper,\n      config,\n    ) as PopperInstance;\n  }\n\n  function runMountCallback(): void {\n    // Only invoke currentMountCallback after 2 updates\n    // This fixes some bugs in Popper.js (TODO: aim for only 1 update)\n    if (popperUpdates === 0) {\n      popperUpdates++; // 1\n      instance.popperInstance!.update();\n    } else if (currentMountCallback && popperUpdates === 1) {\n      popperUpdates++; // 2\n      reflow(popper);\n      currentMountCallback();\n    }\n  }\n\n  function mount(): void {\n    // The mounting callback (`currentMountCallback`) is only run due to a\n    // popperInstance update/create\n    popperUpdates = 0;\n\n    const {appendTo} = instance.props;\n\n    let parentNode: any;\n\n    // By default, we'll append the popper to the triggerTargets's parentNode so\n    // it's directly after the reference element so the elements inside the\n    // tippy can be tabbed to\n    // If there are clipping issues, the user can specify a different appendTo\n    // and ensure focus management is handled correctly manually\n    const node = getCurrentTarget();\n\n    if (\n      (instance.props.interactive && appendTo === defaultProps.appendTo) ||\n      appendTo === 'parent'\n    ) {\n      parentNode = node.parentNode;\n    } else {\n      parentNode = invokeWithArgsOrReturn(appendTo, [node]);\n    }\n\n    // The popper element needs to exist on the DOM before its position can be\n    // updated as Popper.js needs to read its dimensions\n    if (!parentNode.contains(popper)) {\n      parentNode.appendChild(popper);\n    }\n\n    if (__DEV__) {\n      // Accessibility check\n      warnWhen(\n        instance.props.interactive &&\n          appendTo === defaultProps.appendTo &&\n          node.nextElementSibling !== popper,\n        `Interactive tippy element may not be accessible via keyboard\n        navigation because it is not directly after the reference element in\n        the DOM source order.\n\n        Using a wrapper <div> or <span> tag around the reference element solves\n        this by creating a new parentNode context.\n        \n        Specifying \\`appendTo: document.body\\` silences this warning, but it\n        assumes you are using a focus management solution to handle keyboard\n        navigation.\n        \n        See: https://atomiks.github.io/tippyjs/accessibility/#interactivity`,\n      );\n    }\n\n    if (instance.popperInstance) {\n      setFlipModifierEnabled(\n        instance.popperInstance.modifiers,\n        instance.props.flip,\n      );\n\n      instance.popperInstance.enableEventListeners();\n\n      // Mounting callback invoked in `onUpdate`\n      instance.popperInstance.update();\n    } else {\n      // Mounting callback invoked in `onCreate`\n      createPopperInstance();\n\n      instance.popperInstance!.enableEventListeners();\n    }\n  }\n\n  function scheduleShow(event?: Event): void {\n    instance.clearDelayTimeouts();\n\n    if (!instance.popperInstance) {\n      createPopperInstance();\n    }\n\n    if (event) {\n      invokeHook('onTrigger', [instance, event]);\n    }\n\n    addDocumentMouseDownListener();\n\n    const delay = getDelay(true);\n\n    if (delay) {\n      showTimeout = setTimeout((): void => {\n        instance.show();\n      }, delay);\n    } else {\n      instance.show();\n    }\n  }\n\n  function scheduleHide(event: Event): void {\n    instance.clearDelayTimeouts();\n\n    invokeHook('onUntrigger', [instance, event]);\n\n    if (!instance.state.isVisible) {\n      removeDocumentMouseDownListener();\n\n      return;\n    }\n\n    const delay = getDelay(false);\n\n    if (delay) {\n      hideTimeout = setTimeout((): void => {\n        if (instance.state.isVisible) {\n          instance.hide();\n        }\n      }, delay);\n    } else {\n      // Fixes a `transitionend` problem when it fires 1 frame too\n      // late sometimes, we don't want hide() to be called.\n      scheduleHideAnimationFrame = requestAnimationFrame((): void => {\n        instance.hide();\n      });\n    }\n  }\n\n  /* ======================= 🔑 Public methods 🔑 ======================= */\n  function enable(): void {\n    instance.state.isEnabled = true;\n  }\n\n  function disable(): void {\n    // Disabling the instance should also hide it\n    // https://github.com/atomiks/tippy.js-react/issues/106\n    instance.hide();\n    instance.state.isEnabled = false;\n  }\n\n  function clearDelayTimeouts(): void {\n    clearTimeout(showTimeout);\n    clearTimeout(hideTimeout);\n    cancelAnimationFrame(scheduleHideAnimationFrame);\n  }\n\n  function setProps(partialProps: Partial<Props>): void {\n    if (__DEV__) {\n      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning('setProps'));\n    }\n\n    if (instance.state.isDestroyed) {\n      return;\n    }\n\n    if (__DEV__) {\n      validateProps(partialProps, plugins);\n    }\n\n    invokeHook('onBeforeUpdate', [instance, partialProps]);\n\n    removeListenersFromTriggerTarget();\n\n    const prevProps = instance.props;\n    const nextProps = evaluateProps(\n      reference,\n      {\n        ...instance.props,\n        ...partialProps,\n        ignoreAttributes: true,\n      },\n      plugins,\n    );\n\n    nextProps.ignoreAttributes = useIfDefined(\n      partialProps.ignoreAttributes,\n      prevProps.ignoreAttributes,\n    );\n\n    instance.props = nextProps;\n\n    addListenersToTriggerTarget();\n\n    if (prevProps.interactiveDebounce !== nextProps.interactiveDebounce) {\n      cleanupInteractiveMouseListeners();\n      debouncedOnMouseMove = debounce(\n        onMouseMove,\n        nextProps.interactiveDebounce,\n      );\n    }\n\n    updatePopperElement(popper, prevProps, nextProps);\n    instance.popperChildren = getChildren(popper);\n\n    // Ensure stale aria-expanded attributes are removed\n    if (prevProps.triggerTarget && !nextProps.triggerTarget) {\n      normalizeToArray(prevProps.triggerTarget).forEach((node): void => {\n        node.removeAttribute('aria-expanded');\n      });\n    } else if (nextProps.triggerTarget) {\n      reference.removeAttribute('aria-expanded');\n    }\n\n    handleAriaExpandedAttribute();\n\n    if (instance.popperInstance) {\n      if (\n        POPPER_INSTANCE_DEPENDENCIES.some((prop): boolean => {\n          return (\n            hasOwnProperty(partialProps, prop as string) &&\n            partialProps[prop] !== prevProps[prop]\n          );\n        })\n      ) {\n        instance.popperInstance.destroy();\n        createPopperInstance();\n\n        if (instance.state.isVisible) {\n          instance.popperInstance.enableEventListeners();\n        }\n      } else {\n        instance.popperInstance.update();\n      }\n    }\n\n    invokeHook('onAfterUpdate', [instance, partialProps]);\n  }\n\n  function setContent(content: Content): void {\n    instance.setProps({content});\n  }\n\n  function show(\n    duration: number = getValueAtIndexOrReturn(\n      instance.props.duration,\n      0,\n      defaultProps.duration,\n    ),\n  ): void {\n    if (__DEV__) {\n      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning('show'));\n    }\n\n    // Early bail-out\n    const isAlreadyVisible = instance.state.isVisible;\n    const isDestroyed = instance.state.isDestroyed;\n    const isDisabled = !instance.state.isEnabled;\n    const isTouchAndTouchDisabled =\n      currentInput.isTouch && !instance.props.touch;\n\n    if (\n      isAlreadyVisible ||\n      isDestroyed ||\n      isDisabled ||\n      isTouchAndTouchDisabled\n    ) {\n      return;\n    }\n\n    // Normalize `disabled` behavior across browsers.\n    // Firefox allows events on disabled elements, but Chrome doesn't.\n    // Using a wrapper element (i.e. <span>) is recommended.\n    if (getCurrentTarget().hasAttribute('disabled')) {\n      return;\n    }\n\n    invokeHook('onShow', [instance], false);\n    if (instance.props.onShow(instance) === false) {\n      return;\n    }\n\n    addDocumentMouseDownListener();\n\n    popper.style.visibility = 'visible';\n    instance.state.isVisible = true;\n\n    // Prevent a transition of the popper from its previous position and of the\n    // elements at a different placement\n    // Check if the tippy was fully unmounted before `show()` was called, to\n    // allow for smooth transition for `createSingleton()`\n    if (!instance.state.isMounted) {\n      setTransitionDuration(transitionableElements.concat(popper), 0);\n    }\n\n    currentMountCallback = (): void => {\n      if (!instance.state.isVisible) {\n        return;\n      }\n\n      setTransitionDuration([popper], instance.props.updateDuration);\n      setTransitionDuration(transitionableElements, duration);\n      setVisibilityState(transitionableElements, 'visible');\n\n      handleAriaDescribedByAttribute();\n      handleAriaExpandedAttribute();\n\n      pushIfUnique(mountedInstances, instance);\n\n      updateIOSClass(true);\n\n      instance.state.isMounted = true;\n      invokeHook('onMount', [instance]);\n\n      onTransitionedIn(duration, (): void => {\n        instance.state.isShown = true;\n        invokeHook('onShown', [instance]);\n      });\n    };\n\n    mount();\n  }\n\n  function hide(\n    duration: number = getValueAtIndexOrReturn(\n      instance.props.duration,\n      1,\n      defaultProps.duration,\n    ),\n  ): void {\n    if (__DEV__) {\n      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning('hide'));\n    }\n\n    // Early bail-out\n    const isAlreadyHidden = !instance.state.isVisible && !isBeingDestroyed;\n    const isDestroyed = instance.state.isDestroyed;\n    const isDisabled = !instance.state.isEnabled && !isBeingDestroyed;\n\n    if (isAlreadyHidden || isDestroyed || isDisabled) {\n      return;\n    }\n\n    invokeHook('onHide', [instance], false);\n    if (instance.props.onHide(instance) === false && !isBeingDestroyed) {\n      return;\n    }\n\n    removeDocumentMouseDownListener();\n\n    popper.style.visibility = 'hidden';\n    instance.state.isVisible = false;\n    instance.state.isShown = false;\n\n    setTransitionDuration(transitionableElements, duration);\n    setVisibilityState(transitionableElements, 'hidden');\n\n    handleAriaDescribedByAttribute();\n    handleAriaExpandedAttribute();\n\n    onTransitionedOut(duration, (): void => {\n      instance.popperInstance!.disableEventListeners();\n      instance.popperInstance!.options.placement = instance.props.placement;\n\n      popper.parentNode!.removeChild(popper);\n\n      mountedInstances = mountedInstances.filter(\n        (i): boolean => i !== instance,\n      );\n\n      if (mountedInstances.length === 0) {\n        updateIOSClass(false);\n      }\n\n      instance.state.isMounted = false;\n      invokeHook('onHidden', [instance]);\n    });\n  }\n\n  function destroy(): void {\n    if (__DEV__) {\n      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning('destroy'));\n    }\n\n    if (instance.state.isDestroyed) {\n      return;\n    }\n\n    isBeingDestroyed = true;\n\n    instance.clearDelayTimeouts();\n    instance.hide(0);\n\n    removeListenersFromTriggerTarget();\n\n    delete reference._tippy;\n\n    if (instance.popperInstance) {\n      instance.popperInstance.destroy();\n    }\n\n    isBeingDestroyed = false;\n    instance.state.isDestroyed = true;\n\n    invokeHook('onDestroy', [instance]);\n  }\n}\n","import {version} from '../package.json';\nimport {defaultProps} from './props';\nimport createTippy, {mountedInstances} from './createTippy';\nimport bindGlobalEventListeners, {\n  currentInput,\n} from './bindGlobalEventListeners';\nimport {getArrayOfElements, isReferenceElement, isElement} from './utils';\nimport {warnWhen, validateTargets, validateProps} from './validation';\nimport {Props, Instance, Targets, HideAllOptions, Plugin, Tippy} from './types';\n\n/**\n * Exported module\n */\nfunction tippy(\n  targets: Targets,\n  optionalProps?: Partial<Props>,\n  plugins: Plugin[] = [],\n): Instance | Instance[] {\n  if (__DEV__) {\n    validateTargets(targets);\n    validateProps(optionalProps, plugins);\n  }\n\n  bindGlobalEventListeners();\n\n  const props: Props = {...defaultProps, ...optionalProps};\n\n  const elements = getArrayOfElements(targets);\n\n  if (__DEV__) {\n    const isSingleContentElement = isElement(props.content);\n    const isMoreThanOneReferenceElement = elements.length > 1;\n    warnWhen(\n      isSingleContentElement && isMoreThanOneReferenceElement,\n      `tippy() was passed an Element as the \\`content\\` prop, but more than one\n      tippy instance was created by this invocation. This means the content\n      element will only be appended to the last tippy instance.\n      \n      Instead, pass the .innerHTML of the element, or use a function that\n      returns a cloned version of the element instead.\n      \n      1) content: () => element.cloneNode(true)\n      2) content: element.innerHTML`,\n    );\n  }\n\n  const instances = elements.reduce<Instance[]>(\n    (acc, reference): Instance[] => {\n      const instance = reference && createTippy(reference, props, plugins);\n\n      if (instance) {\n        acc.push(instance);\n      }\n\n      return acc;\n    },\n    [],\n  );\n\n  return isElement(targets) ? instances[0] : instances;\n}\n\ntippy.version = version;\ntippy.defaultProps = defaultProps;\ntippy.setDefaultProps = setDefaultProps;\ntippy.currentInput = currentInput;\n\n/**\n * Mutates the defaultProps object by setting the props specified\n */\nfunction setDefaultProps(partialProps: Partial<Props>): void {\n  if (__DEV__) {\n    validateProps(partialProps, []);\n  }\n\n  Object.keys(partialProps).forEach((key): void => {\n    defaultProps[key] = partialProps[key];\n  });\n}\n\n/**\n * Returns a proxy wrapper function that passes the plugins\n */\nexport function createTippyWithPlugins(outerPlugins: Plugin[]): Tippy {\n  const tippyPluginsWrapper = (\n    targets: Targets,\n    optionalProps?: Partial<Props>,\n    innerPlugins: Plugin[] = [],\n  ): Instance | Instance[] =>\n    tippy(targets, optionalProps, [...outerPlugins, ...innerPlugins]);\n\n  tippyPluginsWrapper.version = version;\n  tippyPluginsWrapper.defaultProps = defaultProps;\n  tippyPluginsWrapper.setDefaultProps = setDefaultProps;\n  tippyPluginsWrapper.currentInput = currentInput;\n\n  return tippyPluginsWrapper;\n}\n\n/**\n * Hides all visible poppers on the document\n */\nexport function hideAll({\n  exclude: excludedReferenceOrInstance,\n  duration,\n}: HideAllOptions = {}): void {\n  mountedInstances.forEach(instance => {\n    let isExcluded = false;\n\n    if (excludedReferenceOrInstance) {\n      isExcluded = isReferenceElement(excludedReferenceOrInstance)\n        ? instance.reference === excludedReferenceOrInstance\n        : instance.popper === excludedReferenceOrInstance.popper;\n    }\n\n    if (!isExcluded) {\n      instance.hide(duration);\n    }\n  });\n}\n\nexport default tippy;\n","import {Targets, Instance, Props, Plugin} from '../types';\nimport tippy from '..';\nimport {throwErrorWhen} from '../validation';\nimport {removeProperties, normalizeToArray, includes} from '../utils';\nimport {defaultProps} from '../props';\n\ninterface ListenerObj {\n  element: Element;\n  eventType: string;\n  listener: EventListener;\n  options: boolean | object;\n}\n\nconst BUBBLING_EVENTS_MAP = {\n  mouseover: 'mouseenter',\n  focusin: 'focus',\n  click: 'click',\n};\n\n/**\n * Creates a delegate instance that controls the creation of tippy instances\n * for child elements (`target` CSS selector).\n */\nexport default function delegate(\n  targets: Targets,\n  props: Partial<Props> & {target: string},\n  plugins: Plugin[] = [],\n): Instance | Instance[] {\n  if (__DEV__) {\n    throwErrorWhen(\n      !props || !props.target,\n      `You must specify a \\`target\\` prop indicating the CSS selector string\n      matching the target elements that should receive a tippy.`,\n    );\n  }\n\n  let listeners: ListenerObj[] = [];\n  let childTippyInstances: Instance[] = [];\n\n  const {target} = props;\n\n  const nativeProps = removeProperties(props, ['target']);\n  const parentProps = {...nativeProps, trigger: 'manual'};\n  const childProps = {...nativeProps, showOnCreate: true};\n\n  const returnValue = tippy(targets, parentProps, plugins);\n  const normalizedReturnValue = normalizeToArray(returnValue);\n\n  function onTrigger(event: Event): void {\n    if (!event.target) {\n      return;\n    }\n\n    const targetNode = (event.target as Element).closest(target);\n\n    if (!targetNode) {\n      return;\n    }\n\n    // Get relevant trigger with fallbacks:\n    // 1. Check `data-tippy-trigger` attribute on target node\n    // 2. Fallback to `trigger` passed to `delegate()`\n    // 3. Fallback to `defaultProps.trigger`\n    const trigger =\n      targetNode.getAttribute('data-tippy-trigger') ||\n      props.trigger ||\n      defaultProps.trigger;\n\n    // Only create the instance if the bubbling event matches the trigger type\n    if (!includes(trigger, (BUBBLING_EVENTS_MAP as any)[event.type])) {\n      return;\n    }\n\n    const instance = tippy(targetNode, childProps, plugins);\n\n    if (instance) {\n      childTippyInstances = childTippyInstances.concat(instance);\n    }\n  }\n\n  function on(\n    element: Element,\n    eventType: string,\n    listener: EventListener,\n    options: object | boolean = false,\n  ): void {\n    element.addEventListener(eventType, listener, options);\n    listeners.push({element, eventType, listener, options});\n  }\n\n  function addEventListeners(instance: Instance): void {\n    const {reference} = instance;\n\n    on(reference, 'mouseover', onTrigger);\n    on(reference, 'focusin', onTrigger);\n    on(reference, 'click', onTrigger);\n  }\n\n  function removeEventListeners(): void {\n    listeners.forEach(\n      ({element, eventType, listener, options}: ListenerObj): void => {\n        element.removeEventListener(eventType, listener, options);\n      },\n    );\n    listeners = [];\n  }\n\n  function applyMutations(instance: Instance): void {\n    const originalDestroy = instance.destroy;\n    instance.destroy = (shouldDestroyChildInstances = true): void => {\n      if (shouldDestroyChildInstances) {\n        childTippyInstances.forEach((instance): void => {\n          instance.destroy();\n        });\n      }\n\n      childTippyInstances = [];\n\n      removeEventListeners();\n      originalDestroy();\n    };\n\n    addEventListeners(instance);\n  }\n\n  normalizedReturnValue.forEach(applyMutations);\n\n  return returnValue;\n}\n","import {LifecycleHooks, Instance} from '../types';\n\nexport default {\n  name: 'sticky',\n  defaultValue: false,\n  fn(instance: Instance): Partial<LifecycleHooks> {\n    const {reference, popper} = instance;\n\n    function shouldCheck(value: 'reference' | 'popper'): boolean {\n      return instance.props.sticky === true || instance.props.sticky === value;\n    }\n\n    let prevRefRect: ClientRect | null = null;\n    let prevPopRect: ClientRect | null = null;\n\n    function updatePosition(): void {\n      const currentRefRect = shouldCheck('reference')\n        ? reference.getBoundingClientRect()\n        : null;\n      const currentPopRect = shouldCheck('popper')\n        ? popper.getBoundingClientRect()\n        : null;\n\n      if (\n        (currentRefRect && areRectsDifferent(prevRefRect, currentRefRect)) ||\n        (currentPopRect && areRectsDifferent(prevPopRect, currentPopRect))\n      ) {\n        instance.popperInstance!.update();\n      }\n\n      prevRefRect = currentRefRect;\n      prevPopRect = currentPopRect;\n\n      if (instance.state.isMounted) {\n        requestAnimationFrame(updatePosition);\n      }\n    }\n\n    return {\n      onMount(): void {\n        if (instance.props.sticky) {\n          updatePosition();\n        }\n      },\n    };\n  },\n};\n\nfunction areRectsDifferent(\n  rectA: ClientRect | null,\n  rectB: ClientRect | null,\n): boolean {\n  if (rectA && rectB) {\n    return (\n      rectA.top !== rectB.top ||\n      rectA.right !== rectB.right ||\n      rectA.bottom !== rectB.bottom ||\n      rectA.left !== rectB.left\n    );\n  }\n\n  return true;\n}\n","import {hideAll, createTippyWithPlugins} from '../src';\nimport createSingleton from '../src/addons/createSingleton';\nimport delegate from '../src/addons/delegate';\nimport animateFill from '../src/plugins/animateFill';\nimport followCursor from '../src/plugins/followCursor';\nimport inlinePositioning from '../src/plugins/inlinePositioning';\nimport sticky from '../src/plugins/sticky';\nimport {ROUND_ARROW} from '../src/constants';\n\nconst extendedTippy = createTippyWithPlugins([\n  animateFill,\n  followCursor,\n  inlinePositioning,\n  sticky,\n]);\n\nextendedTippy.createSingleton = createSingleton;\nextendedTippy.delegate = delegate;\nextendedTippy.hideAll = hideAll;\nextendedTippy.roundArrow = ROUND_ARROW;\n\nexport default extendedTippy;\n","import {LifecycleHooks, AnimateFillInstance} from '../types';\nimport {BACKDROP_CLASS} from '../constants';\nimport {div, setVisibilityState} from '../utils';\nimport {isUCBrowser} from '../browser';\nimport {warnWhen} from '../validation';\n\nexport default {\n  name: 'animateFill',\n  defaultValue: false,\n  fn(instance: AnimateFillInstance): Partial<LifecycleHooks> {\n    const {tooltip, content} = instance.popperChildren;\n\n    const backdrop =\n      instance.props.animateFill && !isUCBrowser\n        ? createBackdropElement()\n        : null;\n\n    function addBackdropToPopperChildren(): void {\n      instance.popperChildren.backdrop = backdrop;\n    }\n\n    return {\n      onCreate(): void {\n        if (backdrop) {\n          addBackdropToPopperChildren();\n\n          tooltip.insertBefore(backdrop, tooltip.firstElementChild!);\n          tooltip.setAttribute('data-animatefill', '');\n          tooltip.style.overflow = 'hidden';\n\n          instance.setProps({animation: 'shift-away', arrow: false});\n        }\n      },\n      onMount(): void {\n        if (backdrop) {\n          const {transitionDuration} = tooltip.style;\n          const duration = Number(transitionDuration.replace('ms', ''));\n\n          // The content should fade in after the backdrop has mostly filled the\n          // tooltip element. `clip-path` is the other alternative but is not\n          // well-supported and is buggy on some devices.\n          content.style.transitionDelay = `${Math.round(duration / 10)}ms`;\n\n          backdrop.style.transitionDuration = transitionDuration;\n          setVisibilityState([backdrop], 'visible');\n\n          // Warn if the stylesheets are not loaded\n          if (__DEV__) {\n            warnWhen(\n              getComputedStyle(backdrop).position !== 'absolute',\n              `The \\`tippy.js/dist/backdrop.css\\` stylesheet has not been\n              imported!\n              \n              The \\`animateFill\\` plugin requires this stylesheet to work.`,\n            );\n\n            warnWhen(\n              getComputedStyle(tooltip).transform === 'none',\n              `The \\`tippy.js/animations/shift-away.css\\` stylesheet has not\n              been imported!\n              \n              The \\`animateFill\\` plugin requires this stylesheet to work.`,\n            );\n          }\n        }\n      },\n      onShow(): void {\n        if (backdrop) {\n          backdrop.style.transitionDuration = '0ms';\n        }\n      },\n      onHide(): void {\n        if (backdrop) {\n          setVisibilityState([backdrop], 'hidden');\n        }\n      },\n      onAfterUpdate(): void {\n        // With this type of prop, it's highly unlikely it will be changed\n        // dynamically. We'll leave out the diff/update logic it to save bytes.\n\n        // `popperChildren` is assigned a new object onAfterUpdate\n        addBackdropToPopperChildren();\n      },\n    };\n  },\n};\n\nfunction createBackdropElement(): HTMLDivElement {\n  const backdrop = div();\n  backdrop.className = BACKDROP_CLASS;\n  setVisibilityState([backdrop], 'hidden');\n  return backdrop;\n}\n","import {\n  Props,\n  PopperElement,\n  LifecycleHooks,\n  Placement,\n  Instance,\n} from '../types';\nimport {\n  includes,\n  closestCallback,\n  useIfDefined,\n  isMouseEvent,\n  getOwnerDocument,\n} from '../utils';\nimport {getBasePlacement} from '../popper';\nimport {currentInput} from '../bindGlobalEventListeners';\n\nexport default {\n  name: 'followCursor',\n  defaultValue: false,\n  fn(instance: Instance): Partial<LifecycleHooks> {\n    const {reference, popper} = instance;\n\n    // Support iframe contexts\n    // Static check that assumes any of the `triggerTarget` or `reference`\n    // nodes will never change documents, even when they are updated\n    const doc = getOwnerDocument(instance.props.triggerTarget || reference);\n\n    // Internal state\n    let lastMouseMoveEvent: MouseEvent;\n    let triggerEvent: Event | null = null;\n    let isInternallySettingControlledProp = false;\n\n    // These are controlled by this plugin, so we need to store the user's\n    // original prop value\n    const userProps = instance.props;\n\n    function setUserProps(props: Partial<Props>): void {\n      Object.keys(props).forEach((prop): void => {\n        userProps[prop] = useIfDefined(props[prop], userProps[prop]);\n      });\n    }\n\n    // Due to `getVirtualOffsets()`, we need to reverse the placement if it's\n    // shifted (start -> end, and vice-versa)\n    function setNormalizedPlacement(): void {\n      const {placement} = userProps;\n\n      if (!placement) {\n        return;\n      }\n\n      const shift = placement.split('-')[1];\n\n      isInternallySettingControlledProp = true;\n\n      instance.setProps({\n        placement: (getIsEnabled() && shift\n          ? placement.replace(shift, shift === 'start' ? 'end' : 'start')\n          : placement) as Placement,\n      });\n\n      isInternallySettingControlledProp = false;\n    }\n\n    function getIsEnabled(): boolean {\n      return (\n        instance.props.followCursor &&\n        isMouseEvent(triggerEvent) &&\n        !(triggerEvent.clientX === 0 && triggerEvent.clientY === 0)\n      );\n    }\n\n    function getIsInitialBehavior(): boolean {\n      return (\n        currentInput.isTouch ||\n        (instance.props.followCursor === 'initial' && instance.state.isVisible)\n      );\n    }\n\n    function resetReference(): void {\n      if (instance.popperInstance) {\n        instance.popperInstance.reference = reference;\n      }\n    }\n\n    function handleListeners(): void {\n      if (!instance.popperInstance) {\n        return;\n      }\n\n      // Popper's scroll listeners make sense for `true` only. TODO: work out\n      // how to only listen horizontal scroll for \"horizontal\" and vertical\n      // scroll for \"vertical\"\n      if (\n        getIsEnabled() &&\n        (getIsInitialBehavior() || instance.props.followCursor !== true)\n      ) {\n        instance.popperInstance.disableEventListeners();\n      }\n    }\n\n    function triggerLastMouseMove(): void {\n      if (getIsEnabled()) {\n        onMouseMove(lastMouseMoveEvent);\n      }\n    }\n\n    function addListener(): void {\n      doc.addEventListener('mousemove', onMouseMove);\n    }\n\n    function removeListener(): void {\n      doc.removeEventListener('mousemove', onMouseMove);\n    }\n\n    function onMouseMove(event: MouseEvent): void {\n      const {clientX, clientY} = (lastMouseMoveEvent = event);\n\n      if (!instance.popperInstance || !instance.state.currentPlacement) {\n        return;\n      }\n\n      // If the instance is interactive, avoid updating the position unless it's\n      // over the reference element\n      const isCursorOverReference = closestCallback(\n        event.target as Element,\n        (el: Element): boolean => el === reference,\n      );\n\n      const rect = reference.getBoundingClientRect();\n      const {followCursor} = instance.props;\n      const isHorizontal = followCursor === 'horizontal';\n      const isVertical = followCursor === 'vertical';\n      const isVerticalPlacement = includes(\n        ['top', 'bottom'],\n        getBasePlacement(instance.state.currentPlacement),\n      );\n\n      // The virtual reference needs some size to prevent itself from overflowing\n      const {size, x, y} = getVirtualOffsets(popper, isVerticalPlacement);\n\n      if (isCursorOverReference || !instance.props.interactive) {\n        instance.popperInstance.reference = {\n          // @ts-ignore - awaiting popper.js@1.16.0 release\n          referenceNode: reference,\n          // These `client` values don't get used by Popper.js if they are 0\n          clientWidth: 0,\n          clientHeight: 0,\n          getBoundingClientRect: (): DOMRect | ClientRect => ({\n            width: isVerticalPlacement ? size : 0,\n            height: isVerticalPlacement ? 0 : size,\n            top: (isHorizontal ? rect.top : clientY) - y,\n            bottom: (isHorizontal ? rect.bottom : clientY) + y,\n            left: (isVertical ? rect.left : clientX) - x,\n            right: (isVertical ? rect.right : clientX) + x,\n          }),\n        };\n\n        instance.popperInstance.update();\n      }\n\n      if (getIsInitialBehavior()) {\n        removeListener();\n      }\n    }\n\n    return {\n      onAfterUpdate(_, partialProps): void {\n        if (!isInternallySettingControlledProp) {\n          setUserProps(partialProps);\n\n          if (partialProps.placement) {\n            setNormalizedPlacement();\n          }\n        }\n\n        // A new placement causes the popperInstance to be recreated\n        if (partialProps.placement) {\n          handleListeners();\n        }\n\n        // Wait for `.update()` to set `instance.state.currentPlacement` to\n        // the new placement\n        requestAnimationFrame(triggerLastMouseMove);\n      },\n      onMount(): void {\n        triggerLastMouseMove();\n        handleListeners();\n      },\n      onTrigger(_, event): void {\n        // Tapping on touch devices can trigger `mouseenter` then `focus`\n        if (triggerEvent) {\n          return;\n        }\n\n        triggerEvent = event;\n\n        if (isMouseEvent(event)) {\n          lastMouseMoveEvent = event;\n        }\n\n        // With \"initial\" behavior, flipping may be incorrect for the first show\n        if (getIsEnabled() && getIsInitialBehavior()) {\n          isInternallySettingControlledProp = true;\n          instance.setProps({flipOnUpdate: true});\n          isInternallySettingControlledProp = false;\n        } else {\n          instance.setProps({flipOnUpdate: userProps.flipOnUpdate});\n        }\n\n        setNormalizedPlacement();\n\n        if (getIsEnabled()) {\n          // Ignore any trigger events fired immediately after the first one\n          // e.g. `focus` can be fired right after `mouseenter` on touch devices\n          if (event === triggerEvent) {\n            addListener();\n          }\n        } else {\n          resetReference();\n        }\n      },\n      onUntrigger(): void {\n        // If untriggered before showing (`onHidden` will never be invoked)\n        if (!instance.state.isVisible) {\n          removeListener();\n          triggerEvent = null;\n        }\n      },\n      onHidden(): void {\n        removeListener();\n        resetReference();\n        triggerEvent = null;\n      },\n    };\n  },\n};\n\nexport function getVirtualOffsets(\n  popper: PopperElement,\n  isVerticalPlacement: boolean,\n): {\n  size: number;\n  x: number;\n  y: number;\n} {\n  const size = isVerticalPlacement ? popper.offsetWidth : popper.offsetHeight;\n\n  return {\n    size,\n    x: isVerticalPlacement ? size : 0,\n    y: isVerticalPlacement ? 0 : size,\n  };\n}\n","import {\n  Instance,\n  LifecycleHooks,\n  InlinePositioningProps,\n  BasePlacement,\n} from '../types';\nimport {arrayFrom} from '../utils';\nimport {getBasePlacement} from '../popper';\n\n// TODO: Work on a \"cursor\" value so it chooses a rect optimal to the cursor\n// position. This will require the `followCursor` plugin's fixes for overflow\n// due to using event.clientX/Y values. (normalizedPlacement, getVirtualOffsets)\nexport default {\n  name: 'inlinePositioning',\n  defaultValue: false,\n  fn(instance: Instance): Partial<LifecycleHooks> {\n    const {reference} = instance;\n\n    function getIsEnabled(): InlinePositioningProps['inlinePositioning'] {\n      return instance.props.inlinePositioning;\n    }\n\n    return {\n      onHidden(): void {\n        if (getIsEnabled()) {\n          instance.popperInstance!.reference = reference;\n        }\n      },\n      onTrigger(): void {\n        if (!getIsEnabled()) {\n          return;\n        }\n\n        instance.popperInstance!.reference = {\n          // @ts-ignore - awaiting popper.js@1.16.0 release\n          referenceNode: reference,\n          clientWidth: 0,\n          clientHeight: 0,\n          getBoundingClientRect(): ClientRect | DOMRect {\n            return getInlineBoundingClientRect(\n              instance.state.currentPlacement &&\n                getBasePlacement(instance.state.currentPlacement),\n              reference.getBoundingClientRect(),\n              arrayFrom(reference.getClientRects()),\n            );\n          },\n        };\n      },\n    };\n  },\n};\n\nexport function getInlineBoundingClientRect(\n  currentBasePlacement: BasePlacement | null,\n  boundingRect: ClientRect,\n  clientRects: ClientRect[],\n): ClientRect {\n  // Not an inline element, or placement is not yet known\n  if (clientRects.length < 2 || currentBasePlacement === null) {\n    return boundingRect;\n  }\n\n  let rectToUse: ClientRect;\n\n  switch (currentBasePlacement) {\n    case 'top':\n    case 'bottom': {\n      const firstRect = clientRects[0];\n      const lastRect = clientRects[clientRects.length - 1];\n      const isTop = currentBasePlacement === 'top';\n\n      const top = firstRect.top;\n      const bottom = lastRect.bottom;\n      const left = isTop ? firstRect.left : lastRect.left;\n      const right = isTop ? firstRect.right : lastRect.right;\n      const width = right - left;\n      const height = bottom - top;\n\n      rectToUse = {top, bottom, left, right, width, height};\n\n      break;\n    }\n    case 'left':\n    case 'right': {\n      const minLeft = Math.min(...clientRects.map(rects => rects.left));\n      const maxRight = Math.max(...clientRects.map(rects => rects.right));\n      const measureRects = clientRects.filter(rect =>\n        currentBasePlacement === 'left'\n          ? rect.left === minLeft\n          : rect.right === maxRight,\n      );\n\n      const top = measureRects[0].top;\n      const bottom = measureRects[measureRects.length - 1].bottom;\n      const left = minLeft;\n      const right = maxRight;\n      const width = right - left;\n      const height = bottom - top;\n\n      rectToUse = {top, bottom, left, right, width, height};\n\n      break;\n    }\n    default: {\n      rectToUse = boundingRect;\n    }\n  }\n\n  return rectToUse;\n}\n","import {Instance, Props, Plugin} from '../types';\nimport tippy from '..';\nimport {preserveInvocation, useIfDefined} from '../utils';\nimport {defaultProps} from '../props';\nimport {throwErrorWhen} from '../validation';\n\n/**\n * Re-uses a single tippy element for many different tippy instances.\n * Replaces v4's `tippy.group()`.\n */\nexport default function createSingleton(\n  tippyInstances: Instance[],\n  optionalProps?: Partial<Props>,\n  plugins: Plugin[] = [],\n): Instance {\n  if (__DEV__) {\n    throwErrorWhen(\n      !Array.isArray(tippyInstances),\n      `The first argument passed to createSingleton() must be an array of tippy\n      instances.\n  \n      The passed value was: ${tippyInstances}`,\n    );\n  }\n\n  tippyInstances.forEach(instance => {\n    instance.disable();\n  });\n\n  let currentAria: string | null | undefined;\n  let currentTarget: Element;\n\n  const userProps: Partial<Props> = {};\n\n  function setUserProps(props: Partial<Props>): void {\n    Object.keys(props).forEach((prop): void => {\n      userProps[prop] = useIfDefined(props[prop], userProps[prop]);\n    });\n  }\n\n  setUserProps({...defaultProps, ...optionalProps});\n\n  function handleAriaDescribedByAttribute(\n    id: string,\n    isInteractive: boolean,\n    isShow: boolean,\n  ): void {\n    if (!currentAria) {\n      return;\n    }\n\n    if (isShow && !isInteractive) {\n      currentTarget.setAttribute(`aria-${currentAria}`, id);\n    } else {\n      currentTarget.removeAttribute(`aria-${currentAria}`);\n    }\n  }\n\n  const references = tippyInstances.map(instance => instance.reference);\n\n  const props: Partial<Props> = {\n    ...optionalProps,\n    aria: null,\n    triggerTarget: references,\n    onMount(instance) {\n      preserveInvocation(userProps.onMount, instance.props.onMount, [instance]);\n      handleAriaDescribedByAttribute(\n        instance.popperChildren.tooltip.id,\n        instance.props.interactive,\n        true,\n      );\n    },\n    onUntrigger(instance, event): void {\n      preserveInvocation(userProps.onUntrigger, instance.props.onUntrigger, [\n        instance,\n        event,\n      ]);\n      handleAriaDescribedByAttribute(\n        instance.popperChildren.tooltip.id,\n        instance.props.interactive,\n        false,\n      );\n    },\n    onTrigger(instance, event): void {\n      preserveInvocation(userProps.onTrigger, instance.props.onTrigger, [\n        instance,\n        event,\n      ]);\n\n      const target = event.currentTarget as Element;\n      const index = references.indexOf(target);\n\n      currentTarget = target;\n      currentAria = userProps.aria;\n\n      if (instance.state.isVisible) {\n        handleAriaDescribedByAttribute(\n          instance.popperChildren.tooltip.id,\n          instance.props.interactive,\n          true,\n        );\n      }\n\n      instance.setContent(tippyInstances[index].props.content);\n\n      // Due to two updates performed upon mount, the second update will use\n      // this object\n      instance.popperInstance!.reference = {\n        // @ts-ignore - awaiting popper.js@1.16.0 release\n        referenceNode: target,\n        clientHeight: 0,\n        clientWidth: 0,\n        getBoundingClientRect(): ClientRect {\n          return target.getBoundingClientRect();\n        },\n      };\n    },\n    onAfterUpdate(instance, partialProps): void {\n      preserveInvocation(\n        userProps.onAfterUpdate,\n        instance.props.onAfterUpdate,\n        [instance, partialProps],\n      );\n\n      setUserProps(partialProps);\n    },\n    onDestroy(instance): void {\n      preserveInvocation(userProps.onDestroy, instance.props.onDestroy, [\n        instance,\n      ]);\n\n      tippyInstances.forEach(instance => {\n        instance.enable();\n      });\n    },\n  };\n\n  return tippy(document.createElement('div'), props, plugins) as Instance;\n}\n"],"names":["defaultProps","allowHTML","animation","appendTo","document","body","aria","arrow","boundary","content","delay","distance","duration","flip","flipBehavior","flipOnUpdate","hideOnClick","ignoreAttributes","inertia","interactive","interactiveBorder","interactiveDebounce","lazy","maxWidth","multiple","offset","onAfterUpdate","onBeforeUpdate","onCreate","onDestroy","onHidden","onHide","onMount","onShow","onShown","onTrigger","onUntrigger","placement","popperOptions","role","showOnCreate","theme","touch","trigger","triggerTarget","updateDuration","zIndex","POPPER_INSTANCE_DEPENDENCIES","getExtendedProps","props","plugins","reduce","acc","plugin","name","defaultValue","undefined","PASSIVE","passive","IOS_CLASS","POPPER_CLASS","TOOLTIP_CLASS","CONTENT_CLASS","BACKDROP_CLASS","ARROW_CLASS","SVG_ARROW_CLASS","POPPER_SELECTOR","TOOLTIP_SELECTOR","CONTENT_SELECTOR","ARROW_SELECTOR","SVG_ARROW_SELECTOR","currentInput","isTouch","lastMouseMoveTime","onDocumentTouchStart","window","performance","addEventListener","onDocumentMouseMove","now","removeEventListener","onWindowBlur","activeElement","instance","_tippy","blur","state","isVisible","isBrowser","ua","navigator","userAgent","isIE","test","isUCBrowser","isIOS","platform","updateIOSClass","isAdd","shouldAdd","classList","keys","Object","hasOwnProperty","obj","key","call","getArrayOfElements","value","isElement","isType","isNodeList","arrayFrom","Array","isArray","querySelectorAll","getValueAtIndexOrReturn","index","v","getModifier","modifiers","type","str","toString","indexOf","isMouseEvent","invokeWithArgsOrReturn","args","setFlipModifierEnabled","filter","m","enabled","div","createElement","setTransitionDuration","els","forEach","el","style","transitionDuration","setVisibilityState","setAttribute","evaluateProps","reference","out","valueAsString","getAttribute","trim","JSON","parse","e","getDataAttributeProps","debounce","fn","ms","arg","clearTimeout","timeout","setTimeout","preserveInvocation","originalFn","currentFn","slice","closestCallback","element","callback","parentElement","includes","a","b","splitBySpaces","split","Boolean","useIfDefined","nextValue","currentValue","normalizeToArray","concat","getOwnerDocument","elementOrElements","ownerDocument","pushIfUnique","arr","push","appendPxIfNumber","setInnerHTML","html","setContent","contentEl","appendChild","getChildren","popper","tooltip","querySelector","addInertia","createArrowElement","arrowElement","className","addInteractive","updateTransitionEndListener","action","listener","eventName","webkitTransition","getBasePlacement","updateTheme","createPopperElement","id","position","top","left","updatePopperElement","prevProps","nextProps","removeAttribute","removeChild","removeInteractive","removeInertia","mountedInstances","idCounter","mouseMoveListeners","createTippy","collectionProps","showTimeout","hideTimeout","scheduleHideAnimationFrame","lastTriggerEvent","currentMountCallback","currentTransitionEndListener","currentTarget","isBeingDestroyed","didHideDueToDocumentMouseDown","popperUpdates","listeners","debouncedOnMouseMove","onMouseMove","doc","popperChildren","transitionableElements","popperInstance","currentPlacement","isEnabled","isDestroyed","isMounted","isShown","clearDelayTimeouts","cancelAnimationFrame","setProps","partialProps","invokeHook","removeListenersFromTriggerTarget","addListenersToTriggerTarget","cleanupInteractiveMouseListeners","node","handleAriaExpandedAttribute","some","prop","destroy","createPopperInstance","enableEventListeners","update","show","isAlreadyVisible","isDisabled","isTouchAndTouchDisabled","getCurrentTarget","hasAttribute","addDocumentMouseDownListener","visibility","handleAriaDescribedByAttribute","onTransitionEnd","onTransitionedIn","parentNode","contains","mount","hide","isAlreadyHidden","removeDocumentMouseDownListener","onTransitionedOut","disableEventListeners","options","i","length","enable","disable","pluginsHooks","map","scheduleShow","getNormalizedTouchSettings","getIsCustomTouchBehavior","getDelay","isShow","hook","shouldInvokePropsHook","pluginHooks","attr","replace","scheduleHide","onDocumentMouseDown","event","target","on","eventType","handler","onMouseLeave","onBlur","isEventListenerStopped","popperTreeData","clientX","clientY","every","popperRect","exceedsTop","exceedsBottom","bottom","exceedsLeft","exceedsRight","right","isCursorOutsideInteractiveBorder","getBoundingClientRect","relatedTarget","supportsTouch","isTouchEvent","isCustomTouch","applyMutations","data","flipped","attributes","basePlacement","padding","config","eventsEnabled","preventOverflow","boundariesElement","behavior","runMountCallback","onUpdate","Popper","offsetHeight","reflow","requestAnimationFrame","tippy","targets","optionalProps","capture","instances","setDefaultProps","version","BUBBLING_EVENTS_MAP","mouseover","focusin","click","areRectsDifferent","rectA","rectB","outerPlugins","tippyPluginsWrapper","extendedTippy","backdrop","animateFill","createBackdropElement","addBackdropToPopperChildren","insertBefore","firstElementChild","overflow","Number","transitionDelay","Math","round","lastMouseMoveEvent","triggerEvent","isInternallySettingControlledProp","userProps","setNormalizedPlacement","shift","getIsEnabled","followCursor","getIsInitialBehavior","resetReference","handleListeners","triggerLastMouseMove","removeListener","isCursorOverReference","rect","isHorizontal","isVertical","isVerticalPlacement","size","offsetWidth","x","y","getVirtualOffsets","referenceNode","clientWidth","clientHeight","width","height","_","inlinePositioning","currentBasePlacement","boundingRect","clientRects","rectToUse","firstRect","lastRect","isTop","minLeft","min","rects","maxRight","max","measureRects","getInlineBoundingClientRect","getClientRects","shouldCheck","sticky","prevRefRect","prevPopRect","updatePosition","currentRefRect","currentPopRect","innerPlugins","createSingleton","tippyInstances","currentAria","setUserProps","isInteractive","references","delegate","childTippyInstances","nativeProps","clone","removeProperties","parentProps","childProps","returnValue","targetNode","closest","originalDestroy","shouldDestroyChildInstances","addEventListeners","hideAll","excludedReferenceOrInstance","exclude","isExcluded","roundArrow"],"mappings":"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"}